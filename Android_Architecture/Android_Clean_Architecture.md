# 안드로이드 앱 특징 및 설계 원칙
## 안드로이드 앱 특징
- 하나의 진입점, 하나의 프로세스에서 실행되는 일반적인 애플리케이션과 달리 안드로이드 앱은 
액티비티, 프래그먼트, 서비스, 브로드캐스트 리시버 등의 컴포넌트로 구성되며, 여러 프로세스로 실행될 수 있고 진입점 또한 다양
- 사용자가 화면 클릭, 시스템 이벤트, 라이프 사이클 등 다양한 상황 존재
- 짧은 시간 내에 여러 애플리케이션과 상호 작용하는 경우가 많다
  - SNS 앱에서 카메라 앱 열고 결과물 가지고 SNS 앱으로 돌아오는 경우, 쇼핑몰 앱 결제
  - 이러한 과정에서 전화나 알림, 메모리 부족으로 인해 하던 작업이 방해를 받거나 중단되는 경우?!!?!
  - 기존 데이터가 유지되어야 한다!!!!! 이를 적절히 처리해야 한다. 
- 안드로이드 컴포넌트는 언제든지 실행되고 메모리 부족과 같은 시스템 조건으로 인해 의도치 않게 종료될 수 있다.
- 이러한 컴포넌트의 생명 주기는 개발자가 직접 제어하는 것이 아닌 안드로이드 시스템이 제어하기 때문에 데이터 및 상태에 대한 내용을 컴포넌트에 저장하는 것은 위험!
- 하지만 우리는 액티비티나 프래그먼트 같은 UI컴포넌트에서 Context, View, 데이터, 시스템 이벤트 등을 쉽게 참조할 수 있어서 여기에 대부분의 코드를 작성하고는 한다.
- 그럼 앞에서 말한 예외사항에 대응하기도 힘들고 코드가 거대해져 가독성도 떨어진다.
- 그러므로 액티비티와 프래그먼트의 클래스 의존성은 최소화하자.
- 가장 중요한 것은 관심사 분리

## 안드로이드 아키텍처 설계의 중요성
- 웹 프론트엔드에 비해 수많은 이벤트 발생, 시스템 이벤트, 라이프사이클 이벤트 등으로 잘못된 설계를 하면 프로그램의 유지보수성이 극도로 떨어짐
- 이벤트의 처리 결과도 동시다발적으로 불시에 일어날 수 있고, 대응이 지연되면 ANR 발생 -> 반응형 프로그래밍
- 빠른 배포가 어렵다. 수정하고 다시 심사받고.. -> 더 견고한 아키텍처 기반 요구
- 네트워크가 끊어졌어도 동작하는 유연성 필요 -> 유연한 데이터 계층 구현
- 성공한 앱을 더 빨리 확장시키려면? -> 더 많은 모듈화, 더 유연한 아키텍처, 실험 기반 시스템 필요
- 좋은 애플리케이션 설계를 위해서는 어떠한 원칙을 정하고, 그것을 기반으로 프로그램을 작성한다면 적어도 원칙 없이 작성한 코드보다는 더 나은 결과물을 볼 수 있다.
- 어떤 관점에서 봐야 할까?
  - 관심사 분리
  - SOLID 원칙과도 많은 부분이 부합되며, 관심사 분리는 클래스 간의 강한 의존성을 느슨하게 하면서 모듈화 시킨다.
  - 관심사 분리를 통해 모듈화를 성공적으로 마치면 애플리케이션 설계, 배포, 유닛 테스트와 같은 일부의 관점에서 더 높은 자유도가 생긴다. 
  - 코드 또한 단순화되고 유지 보수 측면에서 더 적은 비용이 들어간다.
  - 관심사가 잘 분리될 때 독립적인 개발과 재사용성도 증대하므로, 생산성 또한 향상되는 효과를 누릴 수 있다.
  - 관심사의 분리는 추상화의 일종이다.
  - 대부분의 추상화에서처럼 인터페이스의 추가는 필수이며 실행에 쓰이는 더 순수한 코드가 있는 것이 일반적이다.
## SOLID 원칙(링크)

## 안드로이드 클린 아키텍처
- 사실 모바일 클린 아키텍처 패턴은 따로 존재하지 않는다. 그저 어느정도의 합의라고 생각하자.
- 로버트 마틴 아저씨가 얘기하는 클린 아키텍처에 모바일 클린 아키텍처에 대한 언급은 없다.
- SOLID원칙을 기반으로 한 과녁 형태의 아키텍처를 어떻게 안드로이드 개발에 적용할 수 있을까?의 물음에 대한 결과물이다.
- 정답은 없기 때문에 내가 만들 앱의 특성을 먼저 파악하고 이에 필요하다고 생각하는 부분만 적절히 활용하면 된다.
- 중요한 것은 왜 이렇게 할 것인가
- 어떤 식으로 구현할 지는 우리 앱이 어떤 특성을 갖고있는지에대해 디펜던시가 높기 때문에 클린 아키텍처는 이렇게 해야돼! 라는 생각으로 잘못 구현하면 앱에 복잡성을 필요이상으로 높일 수 있기 때문에 주의가 필요
- 어떤 액터들이 존재하는지 생각하고, 그에 따라서 어떤 책임을 각각의 클래스 모듈 계층들까지 가져야하는지 염두에 두고 설계에 반영하자
- 하나의 결정되어있는 패턴이라든가, 가이드라인이라든가 모던 안드로이드는 꼭 지켜야한다 등의 생각은 하지말자
![Untitled (4)](https://user-images.githubusercontent.com/66052467/184365108-a850ab85-d026-4377-909f-2ac5576796b3.png)
- 코드 종속성이 외부로부터 내부로 의존하는 것이 핵심
- 내부 계층의 코드는 외부 계층의 코드를 알 수 없으며 외부 계층에 존재하는 변수, 함수 및 클래스 등은 안쪽 계층에서 다시 등장할 수 없다.
- 데이터 형식도 계층 간에 별도로 유지하는 것이 좋다.
- 가운데 원은 가장 추상적인 영역으로 비즈니스 로직을 포함하고 사용 중인 플랫폼이나 프레임워크에 의존해선 안 된다.
- 안쪽 계층으로 진입할수록 추상화와 캡슐화 수준이 높아진다.
- 외부 원은 네트워크 및 데이터베이스의 접근처럼 플랫폼에 특정한 구체적인 구현 세부 사항이 포함된다.
- 내부 계층은 외부 계층을 알면 안 된다. 라는 규칙만 지키면 계층을 몇 개로, 어떻게 나누어도 상관없다.

- 도메인 계층(== UseCase)가 가장 높은 수준의 계층
  - 특정 앱이 갖고 있는 니즈
  - 회원가입, 장바구니, 결제 등의 비즈니스 요구 사항들을 담고 있는 계층
- 엔티티
  - 어떠한 업무 규칙을 가지고 있는 업무 룰을 정의
  - 일반적인 데이터 저장소를 얘기하는 것이 아님
- 유즈케이스
  - 일반적인 업무 규칙을 이 앱에서 어떠한 비즈니스 룰을 가지는지 의미
  - 기술적인 단어가 아니라 일반적인 유즈케이스 의미
- 프레젠터
  - 뷰모델이라 생각
  - 유즈케이스에 서비스를 제공
- 게이트웨이
  - 디비나 외부 네트워크에 접근
- 컨트롤러
  - 입력을 받아들이고 외부 장치와 소통
- 맨 바깥은 실제로 입출력에 관련된 것들
- 안으로 갈수록 고수준이고 외부로부터 보호되어있음
- [안드로이드 관점에서 해석한 과녁 클린 아키텍처](https://github.com/dudwls901/Android_Practice/blob/main/Android_Architecture/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EA%B4%80%EC%A0%90%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.md)
- 위의 과녁 클린 아키텍처를 모바일에 적용한다면?
![Untitled (5)](https://user-images.githubusercontent.com/66052467/184365154-75bba488-f3c1-43ee-8214-fdfccb1de5ff.png)
- Repository는 Data Layer쪽으로 굳혀진듯?
- Data Layer에서 사용하는 데이터들을 얘기할 때 Entity와 Model로 나누기도함
- 여기서 얘기하는 Data는 기술적인 Entity와 Model
### UI 계층 (Presentation Layer)
- View
  - 화면 표시와 사용자 입력 담당
  - 플랫폼에 의존적인것은 뷰에서 처리
    - Context (안드로이드)
    - 컨텍스트를 통해 시스템에 접근하는 등
    - 컨텍스트 사용해야 하는 것들은 모두 뷰에서 처리
  - 데이터 계층의 가장 하위 요소는 데이터 입출력
  - UI계층에서 가장 하위 요소는 뷰
  - 뷰가 꼭 액티비티나 프래그먼트를 의미하진 않음
- Presenter
    - MVP의 프레젠터가 아니라 좀 더 넓은 의미
    - 뷰 관점의 비즈니스 로직
    - 플랫폼에 직접적으로 의존하지 않음
    - 플랫폼 디펜던시 없어도 즉 JVM위에서도 단위 테스트가 가능해야함
### 도메인 계층 (Domain Layer)
- 도메인 계층은 굉장히 논쟁적인 부분
- 도메인 관점의 비즈니스 로직이 많이 필요 없다고 생각할 수 있음
- 그런 경우는 굳이 도메인 계층을 가지지 않아도?
- 앱에서 가지고 있는 데이터와 서버쪽의 데이터를 중간에 Translator역할만 한다면 굳이 Domain이 아니라 다른 구분의 계층으로 해도됨
- 어떻게 보면 Domain 계층은 Optional할 수 있음
- 많은 앱들에서 가장 중요한 도메인 로직들은 사실 서버에서 일어나기 때문에!
- UseCase
  - 여러가지 방면으로 구현될 수 있음
  - UI 관점의 비즈니스 로직
  - 도메인 관점의 비즈니스 로직 
    - 도메인 지식을 가지고 있는 로직
    - 개발자가 아닌 사람, 유저와 밀접한 연관이 있는 기획자 등 업무와 관련된 부서가 알아야 하는 업무 규칙이 도메인 관점의 비즈니스 로직
- Model(도메인 모델)
  - 도메인 계층에서 사용할 수 있는 앱의 논리적인 엔티티 데이터
  - 도메인 주도 개발 (DDD)의 도메인 모델과는 좀 차이가 있다.
- Translator
  - 데이터 계층에서 로우레벨하게 받아온 데이터들, DB에 저장하거나, Remote에서 받아오는 것들처럼 서버나 DB관점의 데이터 새부내용과 앱에서 바라보는 데이터 관점이 다를 수 있기 때문에 이를 변환하는 것
  - 데이터 계층의 엔티티 
  - 도메인 모델을 변환하는 mapper
### 데이터 계층 (Data Layer)
- Entity
  - 과녁 그림의 Entity와는 별개
  - 과녁에서 제일 바깥에 있는 것과 바깥에서 두 번째 있는 계층에서 입출력을 담당
- Repository
  - 데이터 계층의 인터페이스
  - 데이터 계층에서 도메인 계층으로, 도메인 계층이 생략된 경우 UI계층으로 어떤 데이터 처리가 이뤄나는지 감춰주는 중요한 역할
  - 고수준의 리포지토리 인터페이스를 통해 어떤 데이터를 얻어오거나 쓰거나 할 수 있음
  - 어떤 데이터를 읽고 쓰는 것에 대한 추상화라는 개념에서 리포지토리란 이름이다 라고 접근
- Data Source
  - 기본적으로 외부 모듈에 대해서 감춰져야 하는 부분
  - 실제 데이터의 입출력이 실행되는 부분
  - 데이터 소스 인터페이스와 그 하부에 여러 데이터 소스를 두어 실제 입출력은 거기서 실행
    - 이는 추상화의 의미가 강함

## References
- TheRED:강사룡의 앱 안정성 및 확장성 강화를 위한 Android 아키텍처
- 아키텍처를 알아야 앱 개발이 보인다 - 옥수환
